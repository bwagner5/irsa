package irsa

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/eks"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	"github.com/google/uuid"
)

type IRSA struct {
	cfg    aws.Config
	iamAPI *iam.Client
	eksAPI *eks.Client
	stsAPI *sts.Client
}

type trustPolicy struct {
	Version   string
	Statement []trustStatement
}

type trustStatement struct {
	Effect    string
	Principal map[string]string
	Action    string
	Condition condition
}
type condition struct {
	StringEquals map[string]string
}

func New(cfg aws.Config) IRSA {
	return IRSA{
		cfg:    cfg,
		iamAPI: iam.NewFromConfig(cfg),
		eksAPI: eks.NewFromConfig(cfg),
		stsAPI: sts.NewFromConfig(cfg),
	}
}

func (i IRSA) Create(ctx context.Context, clusterName string, namespace string,
	serviceAccount string, roleName string, policyARNs []string, policies []string) (string, error) {
	resolvedPolicies, err := i.fetchPolicies(policies)
	if err != nil {
		return "", fmt.Errorf("unable to resolve policies: %w", err)
	}
	newPolicyARNs, err := i.createPolicies(ctx, clusterName, roleName, resolvedPolicies)
	if err != nil {
		return "", fmt.Errorf("unable to create policies: %w", err)
	}
	policyARNs = append(policyARNs, newPolicyARNs...)
	trustPolicy, err := i.getTrustPolicy(ctx, clusterName, namespace, serviceAccount)
	if err != nil {
		return "", err
	}
	createRoleInput := iam.CreateRoleInput{
		RoleName:                 &roleName,
		Description:              aws.String("Role created by the irsa CLI tool"),
		AssumeRolePolicyDocument: aws.String(trustPolicy),
	}
	createRoleOut, err := i.iamAPI.CreateRole(ctx, &createRoleInput)
	if err != nil {
		return "", err
	}
	for _, policyARN := range policyARNs {
		if _, err := i.iamAPI.AttachRolePolicy(ctx, &iam.AttachRolePolicyInput{PolicyArn: aws.String(policyARN), RoleName: aws.String(roleName)}); err != nil {
			return "", err
		}
	}
	return *createRoleOut.Role.Arn, nil
}

func (i IRSA) createPolicies(ctx context.Context, clusterName string, roleName string, policies []string) ([]string, error) {
	var resolvedPolicyARNs []string
	for _, policy := range policies {
		out, err := i.iamAPI.CreatePolicy(ctx, &iam.CreatePolicyInput{
			PolicyDocument: aws.String(policy),
			PolicyName:     aws.String(fmt.Sprintf("%s-%s-%s", clusterName, roleName, uuid.NewString())),
			Description:    aws.String("Policy generated by the irsa CLI tool"),
		})
		if err != nil {
			return nil, fmt.Errorf("unable to create policy")
		}
		resolvedPolicyARNs = append(resolvedPolicyARNs, *out.Policy.Arn)
	}
	return resolvedPolicyARNs, nil
}

func (i IRSA) fetchPolicies(policies []string) ([]string, error) {
	var resolvedpolicies []string
	httpClient := http.Client{Timeout: time.Second * 30}
	for _, policy := range policies {
		if strings.HasPrefix(policy, "file://") {
			policyFromFile, err := os.ReadFile(strings.ReplaceAll(policy, "file://", ""))
			if err != nil {
				return nil, fmt.Errorf("unable to open file %s to read IAM policy", policy)
			}
			resolvedpolicies = append(resolvedpolicies, string(policyFromFile))
		} else if strings.HasPrefix(policy, "http") {
			resp, err := httpClient.Get(policy)
			if err != nil {
				return nil, fmt.Errorf("unable to make http request for %s", policy)
			}
			defer resp.Body.Close()
			if resp.StatusCode >= 400 {
				return nil, fmt.Errorf("received http status %s for %s", resp.Status, policy)
			}
			policyFromURL, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, fmt.Errorf("unable to read response body of %s", policy)
			}
			resolvedpolicies = append(resolvedpolicies, string(policyFromURL))
		} else {
			return nil, fmt.Errorf("invalid policy format, must be prefixed with file:// or http(s)://")
		}
	}
	return resolvedpolicies, nil
}

func (i IRSA) getTrustPolicy(ctx context.Context, clusterName string, namespace string, serviceAccount string) (string, error) {
	out, err := i.eksAPI.DescribeCluster(ctx, &eks.DescribeClusterInput{Name: &clusterName})
	if err != nil {
		return "", err
	}
	if out.Cluster.Identity.Oidc.Issuer == nil {
		return "", fmt.Errorf("no oidc issuer")
	}
	oidcIssuer := strings.ReplaceAll(*out.Cluster.Identity.Oidc.Issuer, "https://", "")
	stsOut, err := i.stsAPI.GetCallerIdentity(ctx, &sts.GetCallerIdentityInput{})
	if err != nil {
		return "", err
	}
	if stsOut.Account == nil {
		return "", fmt.Errorf("aws account id cannot be discovered")
	}
	awsAccountID := *stsOut.Account
	trustPolicy, err := json.Marshal(trustPolicy{
		Version: "2012-10-17",
		Statement: []trustStatement{
			{
				Effect: "Allow",
				Principal: map[string]string{
					"Federated": fmt.Sprintf("arn:aws:iam::%s:oidc-provider/%s", awsAccountID, oidcIssuer),
				},
				Action: "sts:AssumeRoleWithWebIdentity",
				Condition: condition{
					StringEquals: map[string]string{
						fmt.Sprintf("%s:sub", oidcIssuer): fmt.Sprintf("system:serviceaccount:%s:%s", namespace, serviceAccount),
						fmt.Sprintf("%s:aud", oidcIssuer): "sts.amazonaws.com",
					},
				},
			},
		},
	})
	if err != nil {
		return "", err
	}
	return string(trustPolicy), nil
}
